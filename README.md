# Develop macOS Application with ChatGPT

Ollama's long-missing terrible UI for macOS, now finally here without any regrets.

## Introduction

Welcome to "Allama," a macOS application designed to provide a missing UI for Ollama. The decision to name it Allama wasnâ€™t exactly the most thought-out, but I wanted to keep a playful reference to both Llama and Ollama. ðŸ˜„

## Disclaimer

```
This application was 90% generated by ChatGPT-4 omni and is delivered as is.
```
## Usage

1. start ollama server
```
ollama serve
```
2. Run the application

## Purpose

So what are we doing here? The main goal of this project is to develop a proof-of-concept (PoC) by leveraging hands-on coding with ChatGPT to see how it can enhance or even replace developer skills.

## Initial Query

Hereâ€™s how it all started:

> I would like you to develop an Ollama UI for macOS. The application should be similar to ChatGPT, with a left sidebar displaying all chats, an option to create new chats, and a main window where the user can input text and see responses in real time.
> Ollama API: https://github.com/ollama/ollama/blob/main/docs/api.md

The initial version developed a very basic UI, which evolved with further prompts and minor input from me. Since I didnâ€™t request any design patterns or best practices, the first version came up as a single `ContentView.swift` file. Itâ€™s a solid start for refactoring, with everything in one fileâ€”easy to transfer across different chats and improve incrementally.

## Challenges and Surprises

### Hallucinating the API

One of the first challenges I encountered was the hallucination of the Ollama API endpoints by ChatGPT. The responses sometimes invented endpoints that didnâ€™t exist. This issue is not unlike a real developer guessing at an API theyâ€™ve never used before. For example, ChatGPT initially provided endpoints that were entirely fictional, leading to a non-functional app.

### UI Design and Layout

Initial UI design was basic, but great comparing my request. The layout was a simple sidebar and main chat window with some lags. While functional, it required significant improvement to meet user expectations for a polished app.
I would recommend to be more descriptive here, explaining columns, captions and navigation and even provide some wireframes before start.

### State Management

State management in the first iteration was mostly missing. ChatGPT handled chat history using local state without any persistence layer, meaning all data was lost upon closing the application. This was far from ideal for such application and should be considered on beginning.

### SQLite Integration

When I prompted ChatGPT to integrate SQLite for chat history, the initial implementation was overly simplistic, creating a single table with minimal fields. It didnâ€™t account for timestamps, roles, or model names. I had to repeatedly refine the prompts to get a more detailed and useful database schema. For instance, I wanted fields for message timestamps, sender roles (user or bot), and the model name used for generating responses.

### Implementing Real-Time Responses

I wanted the application to render responses from the API stream immediately, just like ChatGPT does. Sounds simple, right? Wrong. This seemingly straightforward task turned into an absolute nightmare )) The initial design published the full message only when the chat response was complete, which was useless for my needs.

Changing this required multiple iterations and very specific instructions about modifying existing messages with new lines from the stream. I spent more time here than I'd care to admit, always ending up frustrated. Every tweak led to new issues, making the whole process a massive headache. Honestly, this part almost made me want to throw in the towel ))

### Settings Screen

Adding a settings screen was another challenge. It needed to allow users to change the API URL, enable the server, and pull new models.

While the initial prompt for this was interpreted quite easily, the UI implementation had its issues.

Ensuring the settings were saved and properly applied required more fine-tuning than anticipated.

### Compiling and Running

Another persistent challenge was ensuring that the code compiled and ran correctly after each modification. Often, changes suggested by ChatGPT led to runtime issues that werenâ€™t immediately apparent. This necessitated a cycle of trial and error, where I had to identify the problems, correct the prompts, and re-test the application.

### Refactoring for MVVM

Refactoring the initial code to follow the MVVM was particularly challenging. ChatGPT managed to produce a basic directory structure, but integrating the actual code blocks within this structure was complex. The context became too spread out, and after several attempts, the code often failed to compile due to various reasons like misplaced logic or missing references.

## Final Thoughts

After a few hours of playing with the app, I decided to stop tweaking and push the changes with minor improvements. You can review and even attempt to run the application.

I wonâ€™t say I was fully satisfied with the processâ€”it was curious, sometimes annoying, but still intriguing to not saying fucking great :-).
The more code I got, the more hallucinations it delivered, from APIs to Swift tools. However, itâ€™s a good approach as long as you can control it. From my understanding, maybe *today*, it wonâ€™t replace developers :-) But developers who understand how it works and more important - how to use it, will find their coding experience drastically different.

## License

This project is licensed under the MIT License - see the LICENSE file for details.

